using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Kode.Agent.SourceGenerator;

/// <summary>
/// Source generator that automatically generates JSON Schema for tool argument classes.
/// </summary>
[Generator]
#pragma warning disable RS1036
public class ToolSchemaGenerator : IIncrementalGenerator
#pragma warning restore RS1036
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateToolSchemaAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all classes with [GenerateToolSchema] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateClass(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDecl.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var name = attribute.Name.ToString();
                if (name is "GenerateToolSchema" or "GenerateToolSchemaAttribute")
                {
                    return classDecl;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, IEnumerable<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        foreach (var classDecl in classes.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);

            if (classSymbol is null)
            {
                continue;
            }

            var source = GenerateSchemaClass(classSymbol);
            context.AddSource($"{classSymbol.Name}Schema.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateSchemaClass(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var schemaClassName = $"{className}Schema";

        var properties = new List<PropertyInfo>();

        foreach (var member in classSymbol.GetMembers())
        {
            if (member is IPropertySymbol { DeclaredAccessibility: Accessibility.Public } property)
            {
                var description = GetPropertyDescription(property);
                var isRequired = IsPropertyRequired(property);
                var jsonType = GetJsonType(property.Type);

                properties.Add(new PropertyInfo
                {
                    Name = ToCamelCase(property.Name),
                    Type = jsonType.Type,
                    Format = jsonType.Format,
                    Description = description,
                    IsRequired = isRequired,
                    IsNullable = property.NullableAnnotation == NullableAnnotation.Annotated
                });
            }
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated JSON Schema for <see cref=\"{className}\"/>.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public static class {schemaClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the JSON Schema as a dictionary.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static Dictionary<string, object> Schema { get; } = new()");
        sb.AppendLine("    {");
        sb.AppendLine("        [\"type\"] = \"object\",");
        sb.AppendLine("        [\"properties\"] = new Dictionary<string, object>");
        sb.AppendLine("        {");

        foreach (var prop in properties)
        {
            sb.AppendLine($"            [\"{prop.Name}\"] = new Dictionary<string, object>");
            sb.AppendLine("            {");

            sb.AppendLine(prop.IsNullable
                ? $"                [\"type\"] = new[] {{ \"{prop.Type}\", \"null\" }},"
                : $"                [\"type\"] = \"{prop.Type}\",");

            if (!string.IsNullOrEmpty(prop.Format))
            {
                sb.AppendLine($"                [\"format\"] = \"{prop.Format}\",");
            }

            sb.AppendLine($"                [\"description\"] = \"{EscapeString(prop.Description)}\"");
            sb.AppendLine("            },");
        }

        sb.AppendLine("        },");

        var requiredProps = properties.Where(p => p.IsRequired).Select(p => $"\"{p.Name}\"");
        var enumerable = requiredProps as string[] ?? requiredProps.ToArray();
        if (enumerable.Any())
        {
            sb.AppendLine($"        [\"required\"] = new[] {{ {string.Join(", ", enumerable)} }}");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetPropertyDescription(IPropertySymbol property)
    {
        // Try to get from ToolParameterAttribute
        foreach (var attr in property.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "ToolParameterAttribute")
            {
                foreach (var arg in attr.NamedArguments)
                {
                    if (arg is { Key: "Description", Value.Value: string desc })
                    {
                        return desc;
                    }
                }
            }
        }

        // Try to get from XML documentation
        var xml = property.GetDocumentationCommentXml();
        if (xml is { Length: > 0 })
        {
            var start = xml.IndexOf("<summary>", StringComparison.Ordinal);
            var end = xml.IndexOf("</summary>", StringComparison.Ordinal);
            if (start >= 0 && end > start)
            {
                var summary = xml.Substring(start + 9, end - start - 9).Trim();
                return summary;
            }
        }

        return "";
    }

    private static bool IsPropertyRequired(IPropertySymbol property)
    {
        // Check ToolParameterAttribute
        foreach (var attr in property.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "ToolParameterAttribute")
            {
                foreach (var arg in attr.NamedArguments)
                {
                    if (arg is { Key: "Required", Value.Value: bool required })
                    {
                        return required;
                    }
                }

                return true; // Default is required
            }
        }

        // Nullable types are not required by default
        return property.NullableAnnotation != NullableAnnotation.Annotated;
    }

    private static (string Type, string? Format) GetJsonType(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();

        // Handle nullable
        if (type.NullableAnnotation == NullableAnnotation.Annotated && type is INamedTypeSymbol
            {
                TypeArguments.Length: > 0
            } namedType)
        {
            return GetJsonType(namedType.TypeArguments[0]);
        }

        return typeName switch
        {
            "string" or "System.String" => ("string", null),
            "int" or "System.Int32" => ("integer", null),
            "long" or "System.Int64" => ("integer", null),
            "short" or "System.Int16" => ("integer", null),
            "byte" or "System.Byte" => ("integer", null),
            "float" or "System.Single" => ("number", null),
            "double" or "System.Double" => ("number", null),
            "decimal" or "System.Decimal" => ("number", null),
            "bool" or "System.Boolean" => ("boolean", null),
            "System.DateTime" => ("string", "date-time"),
            "System.DateTimeOffset" => ("string", "date-time"),
            "System.Guid" => ("string", "uuid"),
            "System.Uri" => ("string", "uri"),
            _ when typeName.StartsWith("System.Collections.Generic.List<") => ("array", null),
            _ when type.TypeKind == TypeKind.Array => ("array", null),
            _ when type.TypeKind == TypeKind.Enum => ("string", null),
            _ => ("object", null)
        };
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r");
    }

    private class PropertyInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
        public string? Format { get; set; }
        public string Description { get; set; } = "";
        public bool IsRequired { get; set; }
        public bool IsNullable { get; set; }
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Kode.Agent.Sdk.Tools;

/// <summary>
/// Marks a class for automatic JSON Schema generation.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public sealed class GenerateToolSchemaAttribute : System.Attribute
{
}
";
}